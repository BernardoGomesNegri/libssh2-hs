-- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}{-# LANGUAGE ForeignFunctionInterface #-}



{-# LINE 5 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

module Network.SSH.Client.LibSSH2.Foreign where

import Foreign
import Foreign.Ptr
import Foreign.C.Types
import Foreign.C.String
import Network.Socket
import Data.Bits

newtype Session = Session (Ptr (Session))
{-# LINE 16 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

newtype KnownHosts = KnownHosts (Ptr (KnownHosts))
{-# LINE 18 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

newtype Channel = Channel (Ptr (Channel))
{-# LINE 20 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

data KnownHostType =
    TYPE_MASK
  | TYPE_PLAIN
  | TYPE_SHA1
  | TYPE_CUSTOM
  | KEYENC_MASK
  | KEYENC_RAW
  | KEYENC_BASE64
  | KEY_MASK
  | KEY_SHIFT
  | KEY_RSA1
  | KEY_SSHRSA
  | KEY_SSHDSS
  deriving (Eq, Show)

kht2int :: KnownHostType -> CInt
kht2int TYPE_MASK   = 0xffff
kht2int TYPE_PLAIN  = 1
kht2int TYPE_SHA1   = 2
kht2int TYPE_CUSTOM = 3
kht2int KEYENC_MASK = 3 `shiftL` 16
kht2int KEYENC_RAW  = 1 `shiftL` 16
kht2int KEYENC_BASE64 = 2 `shiftL` 16
kht2int KEY_MASK    = 3 `shiftL` 18
kht2int KEY_SHIFT   = 18
kht2int KEY_RSA1    = 1 `shiftL` 18
kht2int KEY_SSHRSA  = 2 `shiftL` 18
kht2int KEY_SSHDSS  = 3 `shiftL` 18

typemask2int :: [KnownHostType] -> CInt
typemask2int list = foldr (.|.) 0 (map kht2int list)

data KnownHostResult =
    MATCH
  | MISMATCH
  | NOTFOUND
  | FAILURE
  deriving (Eq, Show, Ord, Enum)

int2khresult :: CInt -> KnownHostResult
int2khresult = toEnum . fromIntegral

data KnownHost = KnownHost {
  khMagic :: CUInt,
  khNode :: Ptr (),
  khName :: String,
  khKey :: String,
  khTypeMask :: [KnownHostType] }
  deriving (Eq, Show)

data Direction = INBOUND | OUTBOUND
  deriving (Eq, Show)

int2dir 1 = [INBOUND]
int2dir 2 = [OUTBOUND]
int2dir 3 = [INBOUND, OUTBOUND]
int2dir x = error $ "Unknown direction: " ++ show x

init_crypto :: Bool -> CInt
init_crypto False = 1
init_crypto True  = 0

ssh2socket :: Socket -> CInt
ssh2socket (MkSocket s _ _ _ _) = s

type CStringCLen = (CString, CUInt)

withCStringLenIntConv :: String -> (CStringCLen -> IO a) -> IO a
withCStringLenIntConv str fn =
  withCStringLen str (\(ptr, len) -> fn (ptr, fromIntegral len))

peekCStringPtr :: Ptr CString -> IO String
peekCStringPtr ptr = peekCString =<< peek ptr

peekMaybeCStringPtr :: Ptr CString -> IO (Maybe String)
peekMaybeCStringPtr ptr = do
  strPtr <- peek ptr
  if strPtr == nullPtr
    then return Nothing
    else Just `fmap` peekCString strPtr

initialize :: Bool -> IO (Int)
initialize a1 =
  let {a1' = init_crypto a1} in 
  initialize'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 104 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

exit :: IO ()
exit =
  exit'_ >>= \res ->
  return ()
{-# LINE 106 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

initSession :: IO Session
initSession = do
  ptr <- libssh2_session_init_ex nullFunPtr nullFunPtr nullFunPtr nullPtr
  return ptr

freeSession :: Session -> IO (Int)
freeSession a1 =
  let {a1' = id a1} in 
  freeSession'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 114 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

disconnectSessionEx :: Session -> Int -> String -> String -> IO (Int)
disconnectSessionEx a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  withCString a3 $ \a3' -> 
  withCString a4 $ \a4' -> 
  disconnectSessionEx'_ a1' a2' a3' a4' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 117 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

disconnectSession :: Session -> String -> IO Int
disconnectSession s msg = disconnectSessionEx s 11 msg ""

handshake :: Session -> Socket -> IO (Int)
handshake a1 a2 =
  let {a1' = id a1} in 
  let {a2' = ssh2socket a2} in 
  handshake'_ a1' a2' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 123 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

initKnownHosts :: Session -> IO (KnownHosts)
initKnownHosts a1 =
  let {a1' = id a1} in 
  initKnownHosts'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 126 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

freeKnownHosts :: KnownHosts -> IO ()
freeKnownHosts a1 =
  let {a1' = id a1} in 
  freeKnownHosts'_ a1' >>= \res ->
  return ()
{-# LINE 129 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

knownHostsReadFile_ :: KnownHosts -> String -> CInt -> IO (Int)
knownHostsReadFile_ a1 a2 a3 =
  let {a1' = id a1} in 
  withCString a2 $ \a2' -> 
  let {a3' = id a3} in 
  knownHostsReadFile_'_ a1' a2' a3' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 132 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

knownHostsReadFile :: KnownHosts -> String -> IO Int
knownHostsReadFile kh path = knownHostsReadFile_ kh path 1

getHostKey :: Session -> IO (String, CUInt, CInt)
getHostKey a1 =
  let {a1' = id a1} in 
  alloca $ \a2' -> 
  alloca $ \a3' -> 
  getHostKey'_ a1' a2' a3' >>= \res ->
  peek  a2'>>= \a2'' -> 
  peek  a3'>>= \a3'' -> 
  peekCString res >>= \res' ->
  return (res', a2'', a3'')
{-# LINE 138 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

checkKnownHost_ :: KnownHosts -> String -> Int -> String -> Int -> [KnownHostType] -> Ptr () -> IO (KnownHostResult)
checkKnownHost_ a1 a2 a3 a4 a5 a6 a7 =
  let {a1' = id a1} in 
  withCString a2 $ \a2' -> 
  let {a3' = fromIntegral a3} in 
  withCString a4 $ \a4' -> 
  let {a5' = fromIntegral a5} in 
  let {a6' = typemask2int a6} in 
  let {a7' = castPtr a7} in 
  checkKnownHost_'_ a1' a2' a3' a4' a5' a6' a7' >>= \res ->
  let {res' = int2khresult res} in
  return (res')
{-# LINE 147 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

checkKnownHost :: KnownHosts -> String -> Int -> String -> [KnownHostType] -> IO KnownHostResult
checkKnownHost kh host port key mask = checkKnownHost_ kh host port key (length key) mask nullPtr

publicKeyAuthFile :: Session -> String -> String -> String -> String -> IO (Int)
publicKeyAuthFile a1 a2 a3 a4 a5 =
  let {a1' = id a1} in 
  withCStringLenIntConv a2 $ \(a2'1, a2'2) -> 
  withCString a3 $ \a3' -> 
  withCString a4 $ \a4' -> 
  withCString a5 $ \a5' -> 
  publicKeyAuthFile'_ a1' a2'1  a2'2 a3' a4' a5' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 153 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

openSessionChannelEx :: Session -> String -> Int -> Int -> String -> IO (Channel)
openSessionChannelEx a1 a2 a3 a4 a5 =
  let {a1' = id a1} in 
  withCStringLenIntConv a2 $ \(a2'1, a2'2) -> 
  let {a3' = fromIntegral a3} in 
  let {a4' = fromIntegral a4} in 
  withCStringLenIntConv a5 $ \(a5'1, a5'2) -> 
  openSessionChannelEx'_ a1' a2'1  a2'2 a3' a4' a5'1  a5'2 >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 159 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

openChannelSession :: Session -> IO Channel
openChannelSession s = openSessionChannelEx s "session" 65536 32768 ""

channelProcess :: Channel -> String -> String -> IO (Int)
channelProcess a1 a2 a3 =
  let {a1' = id a1} in 
  withCStringLenIntConv a2 $ \(a2'1, a2'2) -> 
  withCStringLenIntConv a3 $ \(a3'1, a3'2) -> 
  channelProcess'_ a1' a2'1  a2'2 a3'1  a3'2 >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 167 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

channelExecute :: Channel -> String -> IO Int
channelExecute c command = channelProcess c "exec" command

channelShell :: Channel -> String -> IO Int
channelShell c command = channelProcess c "shell" command

readChannelEx :: Channel -> Int -> Int -> IO (Int, String)
readChannelEx a1 a2 a4 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  alloca $ \a3' -> 
  let {a4' = fromIntegral a4} in 
  readChannelEx'_ a1' a2' a3' a4' >>= \res ->
  peekCString  a3'>>= \a3'' -> 
  let {res' = fromIntegral res} in
  return (res', a3'')
{-# LINE 179 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

readChannel :: Channel -> Int -> IO (Int, String)
readChannel c sz = readChannelEx c 0 sz

closeChannel :: Channel -> IO (Int)
closeChannel a1 =
  let {a1' = id a1} in 
  closeChannel'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 185 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

freeChannel :: Channel -> IO (Int)
freeChannel a1 =
  let {a1' = id a1} in 
  freeChannel'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 188 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

blockedDirections :: Session -> IO ([Direction])
blockedDirections a1 =
  let {a1' = id a1} in 
  blockedDirections'_ a1' >>= \res ->
  let {res' = int2dir res} in
  return (res')
{-# LINE 191 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

channelExitStatus :: Channel -> IO (Int)
channelExitStatus a1 =
  let {a1' = id a1} in 
  channelExitStatus'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 194 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

channelExitSignal_ :: Channel -> Ptr Int -> Ptr Int -> Ptr Int -> IO (Int, String, Maybe String, Maybe String)
channelExitSignal_ a1 a3 a5 a7 =
  let {a1' = id a1} in 
  alloca $ \a2' -> 
  let {a3' = castPtr a3} in 
  alloca $ \a4' -> 
  let {a5' = castPtr a5} in 
  alloca $ \a6' -> 
  let {a7' = castPtr a7} in 
  channelExitSignal_'_ a1' a2' a3' a4' a5' a6' a7' >>= \res ->
  peekCStringPtr  a2'>>= \a2'' -> 
  peekMaybeCStringPtr  a4'>>= \a4'' -> 
  peekMaybeCStringPtr  a6'>>= \a6'' -> 
  let {res' = fromIntegral res} in
  return (res', a2'', a4'', a6'')
{-# LINE 203 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

channelExitSignal :: Channel -> IO (Int, String, Maybe String, Maybe String)
channelExitSignal ch = channelExitSignal_ ch nullPtr nullPtr nullPtr

getLastError_ :: Session -> Ptr Int -> Int -> IO (Int, String)
getLastError_ a1 a3 a4 =
  let {a1' = id a1} in 
  alloca $ \a2' -> 
  let {a3' = castPtr a3} in 
  let {a4' = fromIntegral a4} in 
  getLastError_'_ a1' a2' a3' a4' >>= \res ->
  peekCStringPtr  a2'>>= \a2'' -> 
  let {res' = fromIntegral res} in
  return (res', a2'')
{-# LINE 212 "Network/SSH/Client/LibSSH2/Foreign.chs" #-}

getLastError :: Session -> IO (Int, String)
getLastError s = getLastError_ s nullPtr 0


foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_init"
  initialize'_ :: (CInt -> (IO CInt))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_exit"
  exit'_ :: (IO ())

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_session_init_ex"
  libssh2_session_init_ex :: ((FunPtr (CUInt -> ((Ptr (Ptr ())) -> (IO (Ptr ()))))) -> ((FunPtr ((Ptr ()) -> ((Ptr (Ptr ())) -> (IO ())))) -> ((FunPtr ((Ptr ()) -> (CUInt -> ((Ptr (Ptr ())) -> (IO (Ptr ())))))) -> ((Ptr ()) -> (IO (Session))))))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_session_free"
  freeSession'_ :: ((Session) -> (IO CInt))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_session_disconnect_ex"
  disconnectSessionEx'_ :: ((Session) -> (CInt -> ((Ptr CChar) -> ((Ptr CChar) -> (IO CInt)))))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_session_handshake"
  handshake'_ :: ((Session) -> (CInt -> (IO CInt)))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_knownhost_init"
  initKnownHosts'_ :: ((Session) -> (IO (KnownHosts)))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_knownhost_free"
  freeKnownHosts'_ :: ((KnownHosts) -> (IO ()))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_knownhost_readfile"
  knownHostsReadFile_'_ :: ((KnownHosts) -> ((Ptr CChar) -> (CInt -> (IO CInt))))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_session_hostkey"
  getHostKey'_ :: ((Session) -> ((Ptr CUInt) -> ((Ptr CInt) -> (IO (Ptr CChar)))))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_knownhost_checkp"
  checkKnownHost_'_ :: ((KnownHosts) -> ((Ptr CChar) -> (CInt -> ((Ptr CChar) -> (CUInt -> (CInt -> ((Ptr (Ptr ())) -> (IO CInt))))))))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_userauth_publickey_fromfile_ex"
  publicKeyAuthFile'_ :: ((Session) -> ((Ptr CChar) -> (CUInt -> ((Ptr CChar) -> ((Ptr CChar) -> ((Ptr CChar) -> (IO CInt)))))))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_channel_open_ex"
  openSessionChannelEx'_ :: ((Session) -> ((Ptr CChar) -> (CUInt -> (CUInt -> (CUInt -> ((Ptr CChar) -> (CUInt -> (IO (Channel)))))))))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_channel_process_startup"
  channelProcess'_ :: ((Channel) -> ((Ptr CChar) -> (CUInt -> ((Ptr CChar) -> (CUInt -> (IO CInt))))))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_channel_read_ex"
  readChannelEx'_ :: ((Channel) -> (CInt -> ((Ptr CChar) -> (CUInt -> (IO CInt)))))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_channel_close"
  closeChannel'_ :: ((Channel) -> (IO CInt))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_channel_free"
  freeChannel'_ :: ((Channel) -> (IO CInt))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_session_block_directions"
  blockedDirections'_ :: ((Session) -> (IO CInt))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_channel_get_exit_status"
  channelExitStatus'_ :: ((Channel) -> (IO CInt))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_channel_get_exit_signal"
  channelExitSignal_'_ :: ((Channel) -> ((Ptr (Ptr CChar)) -> ((Ptr CUInt) -> ((Ptr (Ptr CChar)) -> ((Ptr CUInt) -> ((Ptr (Ptr CChar)) -> ((Ptr CUInt) -> (IO CInt))))))))

foreign import ccall safe "Network/SSH/Client/LibSSH2/Foreign.chs.h libssh2_session_last_error"
  getLastError_'_ :: ((Session) -> ((Ptr (Ptr CChar)) -> ((Ptr CInt) -> (CInt -> (IO CInt)))))
